#########################################################################################
#########################################################################################
#											#
#	Some basic info about Lepton machines functions and scripts					#
#											#
#########################################################################################
#########################################################################################


#################################################################################
# Some functions defined here (providing parameters and impedance models)								#
#################################################################################


FILE
    ALBA_imp.py

FUNCTIONS

    ALBA_imp(circ=268.0, gamma=5871, avbetax=6.4916999999999998, avbetay=9.1259999999999994, dire='ALBA_lumped/', wake_calc=False, lxplusbatch=None)
        generates impedance model for ALBA ring
        - circ is circumference in m
        - gamma is the relativistic mass factor and circ the total circumference
        - avbetax and avbetay are the average beta functions where to apply kick (must be R/Q for DELPHI computations later)
        - dire is the directory in ImpedanceWake2D where to put the results
        - wake_calc should be True to compute wake as well
        - lxplusbatch: if None, no use of lxplus batch system
                    if 'launch' -> launch calculation on lxplus
                   if 'retrieve' -> retrieve outputs
    

FILE
    LEP.py

FUNCTIONS
    LEP_param(E0)
        generates typical LEP parameters at injection, given the electron rest energy 
        E0 in J (from e.g. function proton_param), and generate dipolar impedance (as two
        broad-band resonators). See Karliner-Popov paper (2005).
        Outputs:
        - machine: string with machine name ('VEPP'),
        - E: beam injection energy in eV (22 GeV),
        - gamma: relativistic mass factor,
        - sigmaz: RMS bunch length in m,
        - taub: total bunch length in s (4*RMS),
        - R: machine pysical radius (circumference/(2 pi)),
        - Qx: total horizontal tune (integer + fractional parts),
        - Qxfrac: fractional horizontal tune,
        - Qs: synchrotron tune,
        - eta: slippage factor (alpha_p-1/gamma^2),
        - M: number of bunches (1),
        - f0: revolution frequency,
        - omega0: revolution angular frequency=2pi*f0,
        - omegas: synchrotron angular frequency=Qs*omega0,
        - dphase: phase of damper w.r.t. "normal" purely resistive damper,
        - nx: coupled-bunch mode number (0),
        - R1: shunt impedance of main broad-band resonator (Ohm/m) in the impedance model
        (including beta function weight),
        - Zx: horizontal dipolar impedance (funcion of frequencies),
        - f: frequencies corresponding to impedance,
        - model: name of impedance model.
    

FILE
    TLEP_conv_2Dplots.py

FUNCTIONS
    
    TLEPZ_param(E0, Zoption=0, flagplot=False, flagsave=False)
        old function to generate typical TLEPZ parameters, given the electron rest energy 
        E0 in J (from e.g. function proton_param) and the impedance option Zoption.
        It also generates a dipolar impedance, depending on Zoption:
        - if Zoption=0: total realistic impedance (RF cavities from Rama Calaga files + resistive-wall)
        - if Zoption=1: RF broadband only
        - if Zoption=2: RF from Rama Calaga only
        - if Zoption=3: resistive wall (RW) only
        - if Zoption=4: total impedance (RF+RW) with RF cavities as broad-band
         
        When flagplot=True, some impedance plots are produced, that are automatically
        saved if flagsave=True (otherwise they are plotted on screen).
        
        Outputs:
        - machine: string with machine name ('TLEPZ'),
        - E: beam energy in eV (45.5 GeV),
        - gamma: relativistic mass factor,
        - sigmaz: RMS bunch length in m,
        - taub: total bunch length in s (4*RMS),
        - R: machine pysical radius (circumference/(2 pi)),
        - Qx: total horizontal tune (integer + fractional parts),
        - Qxfrac: fractional horizontal tune,
        - Qs: synchrotron tune,
        - eta: slippage factor (alpha_p-1/gamma^2),
        - M: number of bunches (1),
        - f0: revolution frequency,
        - omega0: revolution angular frequency=2pi*f0,
        - omegas: synchrotron angular frequency=Qs*omega0,
        - dphase: phase of damper w.r.t. "normal" purely resistive damper,
        - nx: coupled-bunch mode number (0),
        - R1: total shunt impedance of broad-band resonator (Ohm/m) used to model RF cavities,
        (including beta function weight),
        - Zx: horizontal dipolar impedance (funcion of frequencies),
        - f: frequencies corresponding to impedance,
        - model: name of impedance model option chosen,
        - syncdamp: synchrotron transverse damping time (transverse=2*longitudinal) in seconds.
    
FILE
    TLEP_imp.py

FUNCTIONS
    
    TLEP_imp(gamma, circ, avbetax, avbetay, length_dip=11.0, length_absorber=0.5, bending_radius=11000, b=0.014999999999999999, dire='TLEP', wake_calc=False, lxplusbatch=None, option='all')
        Generates TLEP impedance and wake model
        all units are SI.
        gamma is the relativistic mass factor and circ the total circumference
        avbetax and avbetay are the average beta functions (where kick will be applied)
        length_dip is the dipole length, length_absorber the photon absorber length, 
        bending_radius the dipoles bending radius, b the vertical semi-axis
        dire is the directory in ImpedanceWake2D where to put the results
        wake_calc should be True to compute wake as well
        lxplusbatch: if None, no use of lxplus batch system
                       if 'launch' -> launch calculation on lxplus
                       if 'retrieve' -> retrieve outputs
        option:
         -'all': compute total impedance
         -'RW': resistive-wall only
         -'RWnoabs' : resistive-wall without absorber part
         -'BB' : total broad-band part
         -'RF': only broad-band from RF
         -'abs': only absorber part (RW+BB from tapers)
    
    TLEP_param(E=45000000000.0, option='Z', Qxfrac=0.20000000000000001, Qyfrac=0.14999999999999999)
        generate typical TLEP parameters, the beam energy E in eV, the TLEP option 
        ('Z', 'H', 'W', 't', 'tB' or 'Z4C') and the fraction parts of the tunes.
        Outputs:
        - machine: string with machine name(here 'TLEP'+option),
        - E: same as input (beam energy in eV),
        - gamma: relativistic mass factor,
        - sigmaz: RMS bunch length in m,
        - taub: total bunch length in s (4*RMS),
        - R: machine pysical radius (circumference/(2 pi)),
        - Qx: total horizontal tune (integer + fractional parts),
        - Qxfrac: fractional horizontal tune,
        - Qy: total vertical tune (integer + fractional parts),
        - Qyfrac: fractional vertical tune,
        - Qs: synchrotron tune,
        - eta: slippage factor (alpha_p-1/gamma^2),
        - f0: revolution frequency,
        - omega0: revolution angular frequency=2pi*f0,
        - omegas: synchrotron angular frequency=Qs*omega0,
        - dphase: phase of damper w.r.t. "normal" purely resistive damper,
        - Estr: string with energy (e.g. '45GeV').
        - syncdamp: synchrotron transverse damping time (transverse=2*longitudinal) in seconds.
    

FILE
    VEPP.py

FUNCTIONS
    
    VEPP_damper(R, Qx, f0)
        VEPP-4 damper model
        - R: machine (physical) radius, 
        - Qx: total tune (integer+fractional parts),
        - f0: revolution frequency,
        Outputs: "damper impedance" Zd, vs frequencies fd
    
    VEPP_param(E0)
        generates typical VEPP parameters at injection, given the electron rest energy 
        E0 in J (from e.g. function proton_param), and generate dipolar impedance (from
        single broad-band resonator). See Karliner-Popov paper (2005).
        Outputs:
        - machine: string with machine name ('VEPP'),
        - E: beam injection energy in eV (1.8 GeV),
        - gamma: relativistic mass factor,
        - sigmaz: RMS bunch length in m,
        - taub: total bunch length in s (4*RMS),
        - R: machine pysical radius (circumference/(2 pi)),
        - Qx: total horizontal tune (integer + fractional parts),
        - Qxfrac: fractional horizontal tune,
        - Qs: synchrotron tune,
        - eta: slippage factor (alpha_p-1/gamma^2),
        - M: number of bunches (1),
        - f0: revolution frequency,
        - omega0: revolution angular frequency=2pi*f0,
        - omegas: synchrotron angular frequency=Qs*omega0,
        - dphase: phase of damper w.r.t. "normal" purely resistive damper,
        - nx: coupled-bunch mode number (0),
        - R1: shunt impedance of broad-band resonator (Ohm/m) in the impedance model
        (including beta function weight),
        - Zx: horizontal dipolar impedance (funcion of frequencies),
        - f: frequencies corresponding to impedance,
        - model: name of impedance model.
    

#################################################################################
# Script examples
#################################################################################

# All python files here are scripts that can be run from the command line,
# performing certain kinds of Impedance and/or DELPHI computations.
#
# They have to be taken as mere examples; in particular, the oldest ones 
# do not use the latest and highest level DELPHI wrapping functions and can be quite
# inefficient, or even crash. For instance, some might look for HEADTAIL simulation
# files which are local files in N. Mounet workspace; you have to comment/take out
# the corresponding lines (see also below).

# In principle a new script has to be done for any new kind of computation, and these
# examples can serve as starting points.

# If one wants to launch a test, a recent script that should work is (but beware that the computation
of the imepdances is very slow - takes days - maybe some parameters or the queue have to be changed...)
ALBA_imp.py
#(see description below)

# To launch the scripts on a LSF batch system (like lxplus), the procedure is
# (e.g. here with ALBA_imp.py):
# first type
./ALBA_imp.py launch launch
#
# -> this launches the resistive-wall impedance computations on batch jobs (here of collimators)
#
# then when all jobs are finished (and if none crashed)
./ALBA_imp.py retrieve launch
#
# -> this retrieves the resistive-wall impedance computations, computes the impedance model
#  and finally launches the DELPHI computations
# to get instabilities complex tune shifts. Note that if some computations were already done
# (in a previous 'launch'), only computations that were not already performed
# (i.e. for which there is not the file 'outpickle_[name_of_the_computation]' already
# present in the 'root_result' folder - see below) are launched.
#
# Finally, when all jobs are finished: 
./ALBA_imp.py retrieve retrieve
#
# -> this will finally write output files and plots (depending on the scripts).
#
# Note: sometimes there will be a warning, saying that some 'outpickle[...]' file is missing
# The code can still retrieve the results (there will simply be some missing points in the plots...).
# So it is a problem only if too many of such warnings happen, which would mean there is
# a more serious issue (e.g. queue on lxbatch is too short, or computations failed for
# some reason).

# In all these scripts results are put in the folder 'root_result', that is most of the time: 
# ../../../DELPHI_results/[machine_name]/[some_name_related_to_the_script]
# You can change this folder at the beginning of the script.

# Scripts are ~always structured as followed:
# - parameters and scanned parameters definition
# - impedance model computation
# - DELPHI computation (sometimes with Sacherer also)
# - plots of results (typically growth_rate vs Q' or vs. intensity, TMCI plots, etc.).

##########
# Typical variables that are very often used (see also parameters described above in [machine]_param functions)
# in these scripts examples:

- root_result: directory where to put the results
- flagnorm (always 0): 1 if damper matrix normalized at current chromaticity; 0
  if instead it is normalized at zero chroma (which I almost always assume)
- strnorm (always ['','_norm_current_chroma']): (this never changes...) list with 2 strings:
  at the end of all output files, the string strnorm[flagnorm] is added (it is more or less useless...)
- flagsave: 1 to save figures in .png and .eps files, instead of plotting on screen (0 to plot on screen 
  -> very dangerous since there can be many many plots...)
- flagdamperimp: 1 to use frequency dependent damper gain (that you have to provide in Zd,fd),
  0 to use a bunch-by-bunch damper
- wake_calc: True -> compute wake as well (otherwise only impedance)
- kmax: number of converged eigenvalues in DELPHI convergence process (kmax most unstable ones are 
converged within at worst 5%) -> kmax=1 is enough when we look only at most unstable mode
- kmaxplot: number of kept and plotted eigenvalues (in TMCI plot)
- g,a,b: longitudinal distribution parameters, usually from longdistribution_decomp function (from DELPHI.py) 

- typical scan definition:
    
    Scans on beam & machine parameters (all these scans are typically done on top of each others ->
    can make up many many calculations - but remember that intensity scan, damper gain and phase scans, and Qs scans
    take no time)
    * Escan: scan on beam energy (injection, top energy)
    * Qpscan: scan in chromaticity
    * dampscan: damper gain scan (in 1/number_of_damping_turns)
    * Nbscan: intensity scan (number of particles per bunch)
    * Nbscanplot: intensities for which we do plots vs Qp
    * NbscanHEADTAIL[...]: intensities for which we do a comparison vs HEADTAIL
    NOTE: this typically requires access to N. Mounet local files, so you have to deactivate this by 
    making the array empty
    * Mscan: scan on total number of bunches.


- tuneshiftQp: array of complex tuneshifts with all DELPHI results, for all scanned parameters and all kmaxplot modes kept
- tuneshiftm0Qp: array of complex tuneshifts for mode 0 only, for all scanned parameters
- imp_mod: full impedance model (list of components, which are impedance_wake objects from the
impedance library in Impedance.py)
- wake_mod: same but for wake functions.


###########
# Short description of each script (we indicate if the script is old so not using the latest 
# library functionalities or even likely to crash)

# NOTE: in all cases except for SPS_conv_LHC_LAGUNA_collimators.py,
# the first launch is useless and one can do right away
# ./[script_name] retrieve launch
#

    ALBA_imp.py (recent)
    	Generates ALBA impedance model and computes complex tuneshifts from DELPHI. Plots TMCI.
	Note: uses DELPHI_wrapper (highest level encapsulation of DELPHI, with many scans).

    LEP_conv_2Dplots.py (old - not using lxplus batch system so launch simply with ./LEP_conv_2Dplots.py)
    	From LEP 2 broad-band impedance model, computes DELPHI TMCI threshold, scanning damper (resistive
	and reactive) and chromaticity, making 2D plots. Used in N. Mounet talk on TLEP (April 2013).

    LEP_conv.py (old - not using lxplus batch system so launch simply with ./LEP_conv.py)
    	From LEP 2 broad-band impedance model, computes DELPHI TMCI threshold and compare
	with Karliner-Popov 2005. Used in N. Mounet talk on TLEP (April 2013).
    
    LEP.py (old - not using lxplus batch system so launch simply with ./LEP.py)
    	Same as LEP_conv.py but unconverged DELPHI computation (fixed number of modes).
	Used in N. Mounet talk on TLEP (April 2013).

    TLEP_conv_2Dplots.py (old - not using lxplus batch system so launch simply with ./TLEP_conv_2Dplots.py)
    	Computes a preliminary version of TLEP-Z impedance model, computes DELPHI TMCI threshold, scanning damper (resistive
	and reactive) and chromaticity, making 2D plots. Used in N. Mounet talk on TLEP (April 2013).

    TLEP_imp.py (recent - no DELPHI so run with a single launch/retrieve)
    	Computes impedance and wake for TLEP, with a more realistic model (including photo-absorbers).
	Used by Simon While in his TLEP talk in October 2013.

    TLEP_TMCI_2D_Qscan.py (recent)
    	TMCI thresholds in 2D for the previous impedance model of TLEP, with tune scan (aim was to see
	synchro-betatron resonances)

    TLEP_TMCI_conv.py
    	TMCI thresholds for the previous impedance model of TLEP.

    TLEP_TMCI.py (old - not using lxplus batch system so launch simply with ./TLEP_TMCI.py)
    	Not converged DELPHI computation with old TLEP-Z impedance model, to get TMCI.

    VEPP_conv.py (old - not using lxplus batch system so launch simply with ./VEPP_conv.py)
    	Converged DELPHI computation to get TMCI (comparison with Karliner-Popov 2005).	

    VEPP.py (old - not using lxplus batch system so launch simply with ./VEPP.py)
	Not converged DELPHI computation to get TMCI (comparison with Karliner-Popov 2005).
	
	
